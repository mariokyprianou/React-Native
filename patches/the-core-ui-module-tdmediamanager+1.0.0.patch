diff --git a/node_modules/the-core-ui-module-tdmediamanager/src/utilities/FileManager.js b/node_modules/the-core-ui-module-tdmediamanager/src/utilities/FileManager.js
index e9042f5..32305f4 100644
--- a/node_modules/the-core-ui-module-tdmediamanager/src/utilities/FileManager.js
+++ b/node_modules/the-core-ui-module-tdmediamanager/src/utilities/FileManager.js
@@ -12,10 +12,12 @@ const appNamePath = DeviceInfo.getApplicationName();
 
 const { config, fs } = RNFetchBlob;
 
-const fileDirectory = Platform.OS === 'ios' ? fs.dirs.DocumentDir : fs.dirs.PictureDir;
+const fileDirectory = fs.dirs.DocumentDir;
 
 const directoryPath = fileDirectory + '/' + appNamePath + '/';
 
+
+
 async function downloadFiles(files) {
 	if (files && files.length > 0) {
 		const results = [];
@@ -35,6 +37,8 @@ async function downloadFiles(files) {
 	}
 }
 
+
+
 async function filterNewFiles(newFiles) {
 	const allFiles = await getAllSavedFiles();
 
@@ -56,13 +60,93 @@ async function filterNewFiles(newFiles) {
 	return toSaveFiles;
 }
 
+
+ 
+async function downloadFilesWithNames(files) {
+	if (files && files.length > 0) {
+		const results = [];
+		const filesToSave = await filterNewFilesWithNames(files);
+
+		const res = await Promise.all(
+			filesToSave.map(async (it) => {
+				const result = await downloadWithName(it);
+				return { success: result.success, file: it.filename };
+			})
+		);
+		results.push(res);
+
+		if (filesToSave.length === 0) {
+			const allFiles = await getAllSavedFiles();
+			return { success: true, files: allFiles, message: 'already cached, returned existing files' };
+		}
+
+		if (results.length === filesToSave.length) {
+			return { success: true, files: results, message: 'cached all files' };
+		}
+		else if (results.length < filesToSave.length) {
+			return { success: false, files: results, message: 'unable to cache all files' };
+		}
+	}
+}
+
+async function filterNewFilesWithNames(newFiles) {
+	const allFiles = await getAllSavedFiles();
+
+	var toSaveFiles = [];
+
+	if (allFiles && allFiles.length > 0) {
+		allFiles.map((savedFile) => {
+			const result = newFiles.filter((it) => {
+				var name = it.filename;
+				if (!savedFile.includes(name)) return it;
+			});
+
+			toSaveFiles = toSaveFiles.concat(result);
+		});
+	} else {
+		toSaveFiles = newFiles;
+	}
+
+	return toSaveFiles;
+}
+
+async function downloadWithName({filename, url}) {
+
+	const options = {
+		fileCache: true, // this option that makes response data to be stored as a file
+		path: directoryPath + formatDate(new Date()) + '_' + filename,
+		addAndroidDownloads: {
+			useDownloadManager: true,
+			notification: true,
+			mediaScannable: true,
+			path: directoryPath + formatDate(new Date()) + '_' + filename,
+		},
+	};
+
+	return config(options)
+		.fetch('GET', url)
+		.then((res) => {
+			if (res.data) {
+				return { success: true, path: res.data };
+			} else {
+				return { success: false };
+			}
+		})
+		.catch((error) => {
+			console.log(error);
+			return { success: false };
+		});
+}
+
+
+
 async function getAllSavedFiles() {
 	return fs
 		.ls(directoryPath)
 		.then((files) => {
 			return files;
 		})
-		.catch((error) => console.log(error));
+		.catch((error) => console.log("getAllSavedFiles",error));
 }
 
 async function download(url) {
@@ -182,10 +266,26 @@ async function getLocalFile(url) {
 	}
 }
 
+async function getLocalFileByName(filename) {
+	const allFiles = await getAllSavedFiles();
+
+	if (!allFiles || allFiles.length == 0) return { success: false };
+
+	const existingFile = allFiles.find((savedFile) => savedFile.includes(filename));
+
+	if (existingFile) {
+		return { success: true, path: directoryPath + existingFile };
+	} else {
+		return { success: false };
+	}
+}
+
 export default {
 	downloadFiles,
 	clearAllFiles,
 	clearBeforeDate,
 	getAllSavedFiles,
 	getLocalFile,
+	downloadFilesWithNames,
+	getLocalFileByName,
 };
diff --git a/node_modules/the-core-ui-module-tdmediamanager/src/views/VideoView.js b/node_modules/the-core-ui-module-tdmediamanager/src/views/VideoView.js
index c1656ea..1dbd207 100644
--- a/node_modules/the-core-ui-module-tdmediamanager/src/views/VideoView.js
+++ b/node_modules/the-core-ui-module-tdmediamanager/src/views/VideoView.js
@@ -5,29 +5,36 @@
  * Copyright (c) 2020 The Distance
  */
 
-import React, { Component, useLayoutEffect, useEffect, useRef, useState } from 'react';
+import React, { Component, useLayoutEffect, useEffect, useRef, useState, useImperativeHandle, forwardRef } from 'react';
 import { Text, StyleSheet, Image, View, Dimensions } from 'react-native';
 import * as R from 'ramda';
 import Video from 'react-native-video';
 import MediaControls, { PLAYER_STATES } from 'react-native-media-controls';
 import FileManager from '../utilities/FileManager';
 
-export default function VideoView(props) {
-	const { getLocalFile } = FileManager;
+export function CustomVideoView(props, ref) {
+	const { getLocalFile, getLocalFileByName } = FileManager;
 
 	const videoPlayer = useRef(null);
 
+	useImperativeHandle(ref, () => ({
+    pause: () => {
+			onPaused()
+    }
+  }));
+
 	const [containerHeight, setContainerHeight] = useState('31%');
 	const [currentTime, setCurrentTime] = useState(0);
 	const [duration, setDuration] = useState(0);
 	const [isFullScreen, setIsFullScreen] = useState(false);
 	const [isLoading, setIsLoading] = useState(true);
-	const [paused, setPaused] = useState(false);
+	const [paused, setPaused] = useState(!props.autoplay);
 	const [playerState, setPlayerState] = useState(PLAYER_STATES.PLAYING);
-	const [screenType, setScreenType] = useState('content');
+	const [screenType, setScreenType] = useState('cover');
 	const [url, setUrl] = useState(null);
 
 	useEffect(() => {
+		
 		if (props.startInFullScreen) {
 			onFullScreen();
 		}
@@ -40,8 +47,15 @@ export default function VideoView(props) {
 	}, []);
 
 	async function checkForLocalFile() {
-		const res = await getLocalFile(props.url);
+		let res;
+		if (props.filename) {
+		 res = await getLocalFileByName(props.filename);	
+		}
+		else {
+		 res = await getLocalFile(props.url);
+		}
 
+		console.log("Play Existing File",res)
 		if (res.success) {
 			setUrl(res.path);
 		} else {
@@ -57,7 +71,7 @@ export default function VideoView(props) {
 		setPaused(!paused);
 		setPlayerState(newPlayerState);
 
-		props.onPaused && props.onPaused();
+		props.onPaused && props.onPaused(!paused);
 	};
 
 	const onReplay = () => {
@@ -79,7 +93,7 @@ export default function VideoView(props) {
 		setDuration(data.duration);
 		setIsLoading(false);
 
-		props.onLoadEnd && props.onLoadEnd();
+		props.onLoadEnd && props.onLoadEnd(data.duration);
 	};
 
 	const onLoadStart = (data) => {
@@ -103,11 +117,9 @@ export default function VideoView(props) {
 	const onSeeking = (newCurrentTime) => setCurrentTime(newCurrentTime);
 
 	const onFullScreen = () => {
-		if (screenType == 'content') {
-			setScreenType('cover');
+		if (!isFullScreen) {
 			setContainerHeight('100%');
 		} else {
-			setScreenType('content');
 			setContainerHeight('31%');
 		}
 		setIsFullScreen(!isFullScreen);
@@ -120,7 +132,7 @@ export default function VideoView(props) {
 	const renderToolbar = () => <></>;
 
 	return (
-		<View style={{ height: containerHeight }}>
+		<View style={{ height: props.height || containerHeight}}>
 			<Video
 				onEnd={onEnd}
 				onLoad={onLoad}
@@ -135,9 +147,12 @@ export default function VideoView(props) {
 				}}
 				style={styles.mediaPlayer}
 				volume={props.volume || 13}
+				muted={props.muted || false}
+
 			/>
 
-			<MediaControls
+			{props.customControls ? props.customControls : (
+				<MediaControls
 				isFullScreen={isFullScreen}
 				duration={duration}
 				isLoading={isLoading}
@@ -153,6 +168,8 @@ export default function VideoView(props) {
 				fadeOutDelay={3000}
 				showOnStart={false}
 			/>
+			)}
+			
 		</View>
 	);
 }
@@ -175,5 +192,10 @@ const styles = StyleSheet.create({
 		bottom: 0,
 		right: 0,
 		backgroundColor: 'black',
+		
 	},
 });
+
+CustomVideoView = forwardRef(CustomVideoView);
+
+export default CustomVideoView;
\ No newline at end of file
